function [elite,fittEle] = cDE(fittFun, param)
%compact Diferential evolution with DE/rand/1/bin operator
%   The function receives the fitness function and a parameter that must
%   have the next values:
%   param.F:        The value of F for the differential evolution operator
%   param.lowLim:   Vector with the low limits of the decision variables
%   param.upLim:    Vector with the up limits of the decision variables
%   param.CR:       Probability for the binary crossover
%   param.NP:       Value of the virtual population
%   param.D:        Number of decision variables
%   param.maxEval:  Max number of function evaluations
%   param.pe:       Bool value that decide if the algorithm  is persistent
%   param.age:      If the algorithm isn't persistent defines the max value
%   of iterations of the best value
%   The function returns the elite vector (best solutiuon found by the
%   algorithm), and the fitness value of the vector solution.
% TODO: The persistent part of the algorithm must be fixed



    %Load parameters to local variables
    F       = param.F;
    lowLim  = param.lowLim;
    upLim   = param.upLim;
    CR      = param.CR;
    Np      = param.NP;
    D       = param.D;
    maxEval = param.maxEval;
    persis  = param.pe;
    ageDE   = param.age;

    %Save in memory funcion vectors
    muV     = zeros(D,1);   %means
    stdV    = zeros(D,1);   %Standard deviation
    elite   = zeros(D,1);   %Elite value
    ageAct  = 0;            %Initial age value, (used only if persistent algorithm is enabled)
    xoff=zeros(D,1);        %Memory that will contain the offspring

    %Init elite with random vector with initial mean and std
    for i=1:D
        muV(i)  = 0;    %\,Provability vector
        stdV(i) = 10;   %/
        elite(i)  = sampleSolution(muV(i),stdV(i)); 
    end

    fittEle = fittFun(denorm(elite, lowLim, upLim)); %Get fitness value elite, is necesary denormalize the solution.
    

    for nEval = 2 : maxEval
        for i=1:D
            %binary crossover
            if(rand > CR)
                %if the random value is gerater than Cr the elite value is
                %copied to the offspring
                xoff(i)=elite(i);
            else
                %otherwise the xr, xs and xt are generated by means of PV,
                %given that there is not population this step just is
                %necessary when the crossover is used per decision variable
                xr  = sampleSolution(muV(i),stdV(i));
                xs  = sampleSolution(muV(i),stdV(i));
                xt  = sampleSolution(muV(i),stdV(i));
                %Creation of the muttation vector per decision variable
                xoff(i) = xt + F*(xr - xs);
                
                % The vector could be outside the search interval so this part is inorder 
                % to set the individual inside.
                % According to the papper the search space is considered
                % toroidal.
                if(xoff(i) < -1)
                    xoff(i) = xoff(i)+2; 
%                      xoff(i) = -1;    %in case that is not toroidal. 
                elseif (xoff(i) > 1)
                    xoff(i) = xoff(i)-2;
%                      xoff(i) = 1;
                end
            end
        end
        
%Exponential crossover
%         i = randi(D);
%         xr  = sampleSolution(muV(i),stdV(i));
%         xs  = sampleSolution(muV(i),stdV(i));
%         xt  = sampleSolution(muV(i),stdV(i));
%         xoff(i) = xt + F*(xr - xs);
%         if(xoff(i) < -1)
%             xoff(i) = xoff(i)+2;
% %                      xoff(i) = -1;
%         elseif (xoff(i) > 1)
%             xoff(i) = xoff(i)-2;
% %                      xoff(i) = 1;
%         end
%         
%         while rand < CR
%             i=i+1;
%             if i > D
%                 i=1;
%             end
%             
%             xr  = sampleSolution(muV(i),stdV(i));
%             xs  = sampleSolution(muV(i),stdV(i));
%             xt  = sampleSolution(muV(i),stdV(i));
%             xoff(i) = xt + F*(xr - xs);
% 
%             if(xoff(i) < -1)
%                 xoff(i) = xoff(i)+2;
%     %                      xoff(i) = -1;
%             elseif (xoff(i) > 1)
%                 xoff(i) = xoff(i)-2;
%     %                      xoff(i) = 1;
%             end
% 
%         end

        %Evaluation of the offspring
        fittOff = fittFun(denorm(xoff, lowLim, upLim));
        %If the offspring is better than the original elite the PV is updated accordingly.
        %The mean is updated in a toroidal way.
        if(fittOff < fittEle || (ageDE <= ageAct && ~persis))
            
            for i=1:D %update PDF when off is the
                mu = muV(i);
                muV(i)  = muV(i) + (1/Np)*(xoff(i) - elite(i));
                
                if(muV(i) < -1)
                    muV(i) = muV(i)+2;
                elseif (muV(i) > 1)
                    muV(i) = muV(i)-2;
                end
                temp    = stdV(i)^2 + mu^2 - muV(i)^2 + (1/Np)*(xoff(i)^2 - elite(i)^2); %This value coluld be negative
                temp    = sqrt(abs(temp));  %Is need get the absolute value in order to avoid errors
                stdV(i) = min([10, temp]);  %Tis is to avoid the grow of std, the max value is 10
                elite(i)= xoff(i);
                fittEle = fittOff;
                ageAct  = 0;                %Used if not persistent
            end
        else % this part is the same of the if part just invert the elite and offspring to update the PV
            for i=1:D
                mu = muV(i);
                muV(i)  = muV(i) + (1/Np)*(elite(i)-xoff(i));
                if(muV(i) < -1)
                    muV(i) = muV(i)+2;
                elseif (muV(i) > 1)
                    muV(i) = muV(i)-2;
                end
                temp    = stdV(i)^2 + mu^2 - muV(i)^2 + (1/Np)*(elite(i)^2 - xoff(i)^2);
                temp    = sqrt(abs(temp));
                stdV(i) = min([10, temp]);
                ageAct  = ageAct + 1;
            end
        end
    end
end