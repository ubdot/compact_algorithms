function [elite,fittEle] = cDE(fittFun, param)
%compact Diferential evolution with DE/rand/1/bin operator
%   The function receives the fitness function and a parameter that must
%   have the next values:
%   param.F:        The value of F for the differential evolution operator
%   param.lowLim:   Vector with the low limits of the decision variables
%   param.upLim:    Vector with the up limits of the decision variables
%   param.CR:       Probability for the binary crossover
%   param.NP:       Value of the virtual population
%   param.D:        Number of decision variables
%   param.maxEval:  Max number of function evaluations
%   param.pe:       Bool value that decide if the algorithm  is persistent
%   param.age:      If the algorithm isn't persistent defines the max value
%   param.cross_op: Define the crossover operator, 1 binary 2 exponential
%   of iterations of the best value
%   The function returns the elite vector (best solutiuon found by the
%   algorithm), and the fitness value of the vector solution.
% TODO: The persistent part of the algorithm must be fixed



    %Load parameters to local variables
    F       = param.F;
    lowLim  = param.lowLim;
    upLim   = param.upLim;
    CR      = param.CR;
    Np      = param.NP;
    D       = param.D;
    maxEval = param.maxEval;
    persis  = param.pe;
    ageDE   = param.age;
    cross_op= param.cross_op;

    %Save in memory funcion vectors
    muV     = zeros(D,1);   %means
    stdV    = zeros(D,1);   %Standard deviation
    elite   = zeros(D,1);   %Elite value
    ageAct  = 0;            %Initial age value, (used only if persistent algorithm is enabled)
    xoff=zeros(D,1);        %Memory that will contain the offspring

    %Init elite with random vector with initial mean and std
    for i=1:D
        muV(i)  = 0;    %\,Provability vector
        stdV(i) = 10;   %/
        elite(i)  = sampleSolution(muV(i),stdV(i)); 
    end

    fittEle = fittFun(denorm(elite, lowLim, upLim)); %Get fitness value elite, is necesary denormalize the solution.
    

    for nEval = 2 : maxEval
        if cross_op == 1
            k = randi(D);
            for i=1:D
                %binary crossover
                if(rand > CR && k ~= i)
                    %if the random value is gerater than Cr the elite value is
                    %copied to the offspring
                    xoff(i)=elite(i);
                else
                    %otherwise the xr, xs and xt are generated by means of PV,
                    %given that there is not population this step just is
                    %necessary when the crossover is used per decision variable
                    xr  = sampleSolution(muV(i),stdV(i));
                    xs  = sampleSolution(muV(i),stdV(i));
                    xt  = sampleSolution(muV(i),stdV(i));
                    %Creation of the muttation vector per decision variable
                    xoff(i) = xt + F*(xr - xs);
                    
                    % The vector could be outside the search interval so this part is inorder 
                    % to set the individual inside.
                    % According to the papper the search space is considered
                    % toroidal.
                    if(xoff(i) < -1)
                        xoff(i) = xoff(i)+2; 
    %                      xoff(i) = -1;    %in case that is not toroidal. 
                    elseif (xoff(i) > 1)
                        xoff(i) = xoff(i)-2;
    %                      xoff(i) = 1;
                    end
                end
            end
        else
        % Exponential crossover
                xoff=elite;
                i = randi(D);
                pos_temp=i;
                xr  = sampleSolution(muV(i),stdV(i));
                xs  = sampleSolution(muV(i),stdV(i));
                xt  = sampleSolution(muV(i),stdV(i));
                xoff(i) = xt + F*(xr - xs);
                if(xoff(i) < -1)
                    xoff(i) = xoff(i)+2;
        %                      xoff(i) = -1;
                elseif (xoff(i) > 1)
                    xoff(i) = xoff(i)-2;
        %                      xoff(i) = 1;
                end
                
                while rand <= CR
                    i=i+1;
                    if i > D
                        i=1;
                    end
        
                    if i== pos_temp %To prevent inf cicles
                        break;
                    end
                    
                    xr  = sampleSolution(muV(i),stdV(i));
                    xs  = sampleSolution(muV(i),stdV(i));
                    xt  = sampleSolution(muV(i),stdV(i));
                    xoff(i) = xt + F*(xr - xs);
        
                    if(xoff(i) < -1)
                        xoff(i) = xoff(i)+2;
            %                      xoff(i) = -1;
                    elseif (xoff(i) > 1)
                        xoff(i) = xoff(i)-2;
            %                      xoff(i) = 1;
                    end
        
                end
        end
        %Evaluation of the offspring
        fittOff = fittFun(denorm(xoff, lowLim, upLim));
        %If the offspring is better than the original elite the PV is updated accordingly.
        %The mean is updated in a toroidal way.
        if(fittOff < fittEle || (ageDE <= ageAct && ~persis))
            [muV, stdV] = upd_PV(muV, stdV, xoff, elite, Np);
            elite   = xoff;
            fittEle = fittOff;
            ageAct  = 0;                %Used if not persistent
        else % this part is the same of the if part just invert the elite and offspring to update the PV
            [muV, stdV] = upd_PV(muV, stdV, elite, xoff, Np);
            ageAct  = ageAct + 1;
        end
    end
%         disp([muV, stdV] )
end