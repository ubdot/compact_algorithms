function [elite,fittEle] = cDE(fittFun, param)
% function [elite,fittEle, plt] = cDE(fittFun, param)
%compact Diferential evolution with DE/rand/1/bin operator
%   The function receives the fitness function and a parameter that must
%   have the next values:
%   param.F:        The value of F for the differential evolution operator
%   param.lowLim:   Vector with the low limits of the decision variables
%   param.upLim:    Vector with the up limits of the decision variables
%   param.CR:       Probability for the binary crossover
%   param.NP:       Value of the virtual population
%   param.D:        Number of decision variables
%   param.maxEval:  Max number of function evaluations
%   param.cross_op: Define the crossover operator, 1 binary 2 exponential
%   of iterations of the best value
%   The function returns the elite vector (best solutiuon found by the
%   algorithm), and the fitness value of the vector solution.



    %Load parameters to local variables------------------------------------
    F       = param.F;
    lowLim  = param.lowLim;
    upLim   = param.upLim;
    CR      = param.CR;
    Np      = param.NP;
    D       = param.D;
    maxEval = param.maxEval;
    cross_op= param.cross_op;
    %Load parameters to local variables------------------------------------

    %Reserve memory for used vectors---------------------------------------
    muV     = zeros(D,1);   %means
    stdV    = 10*ones(D,1); %Standard deviation
    elite   = zeros(D,1);   %Elite value
    xoff=zeros(D,1);        %Memory that will contain the offspring
    %Reserve memory for used vectors---------------------------------------

%     %Start variables used to save plot each 10D function evaluations
%     smpl    = 10*D;
%     plt     = zeros(1001,1);
%     indPlt  = 1;

    %Init elite with random vector using initial mean and std--------------
    for i=1:D
        elite(i)  = sampleSolution(muV(i),stdV(i)); 
    end
    fittEle = fittFun(denorm(elite, lowLim, upLim)); %Get fitness value elite, is necesary denormalize the solution.  
    %Init elite with random vector using initial mean and std--------------

    %Save first point in plt
%     plt(indPlt)    = fittEle;
%     indPlt  = indPlt + 1;

    for nEval = 2 : maxEval
        if cross_op == 1
            %binary crossover----------------------------------------------
            j = randi(D);
            for i=1:D
                if(rand > CR && i~=j)
                    %if the random value is gerater than Cr the elite value is
                    %copied to the offspring
                    xoff(i)=elite(i);
                else
                    %otherwise the xr, xs and xt are generated by means of PV,
                    %given that there is not population this step just is
                    %necessary when the crossover is used per decision variable
                    xr  = sampleSolution(muV(i),stdV(i));
                    xs  = sampleSolution(muV(i),stdV(i));
                    xt  = sampleSolution(muV(i),stdV(i));
                    %Creation of the muttation vector per decision variable
                    xoff(i) = xt + F*(xr - xs);
                    
                    % The vector could be outside the search interval so this part is inorder 
                    % to set the individual inside.
                    % According to the papper the search space is considered
                    % toroidal.
                    while(xoff(i) < -1)
                        xoff(i) = xoff(i)+2;
                    end
        
                    while(xoff(i) > 1)
                        xoff(i) = xoff(i)-2;
                    end
                end
            end
            %binary crossover----------------------------------------------
        elseif cross_op == 2
            % Exponential crossover----------------------------------------
            xoff=elite;
            i = randi(D);
            pos_temp=i;
                
            xr  = sampleSolution(muV(i),stdV(i));
            xs  = sampleSolution(muV(i),stdV(i));
            xt  = sampleSolution(muV(i),stdV(i));
            xoff(i) = xr + F*(xs - xt);

            if(xoff(i) < -1)
                xoff(i) = xoff(i)+2;
            elseif (xoff(i) > 1)
                xoff(i) = xoff(i)-2;
            end
            
            while rand <= CR
                i=i+1;
                if i > D
                    i=1;
                end
    
                if i== pos_temp %To prevent inf cicles
                    break;
                end
                
                xr  = sampleSolution(muV(i),stdV(i));
                xs  = sampleSolution(muV(i),stdV(i));
                xt  = sampleSolution(muV(i),stdV(i));

                xoff(i) = xt + F*(xr - xs);
                %Bound fix-------------------------------------------------
                while(xoff(i) < -1)
                    xoff(i) = xoff(i)+2;
                end
    
                while(xoff(i) > 1)
                    xoff(i) = xoff(i)-2;
                end
                %Bound fix-------------------------------------------------
    
            end
            % Exponential crossover----------------------------------------
        end
        %Evaluation of the offspring
        fittOff = fittFun(denorm(xoff, lowLim, upLim));
        %Competition-------------------------------------------------------
        %If the offspring is better than the original elite the PV is updated accordingly.
        %The mean is updated in a toroidal way.
        if(fittOff < fittEle)
            [muV, stdV] = upd_PV_D(muV, stdV, xoff, elite, Np);
            elite   = xoff;
            fittEle = fittOff;
        else % this part is the same of the if part just invert the elite and offspring to update the PV
            [muV, stdV] = upd_PV_D(muV, stdV, elite, xoff, Np);
        end
        %Competition-------------------------------------------------------
        %Save best solution
%         if mod(nEval,smpl)==0
%             plt(indPlt) = fittEle;
%             indPlt  = indPlt + 1;
%         end
    end
end